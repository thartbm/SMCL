% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/circleFit.R
\name{circleCorrect}
\alias{circleCorrect}
\title{Shift localization responses so they are centred on the origin}
\usage{
circleCorrect(df, unit = "cm", vrbl = "tap", r = 1, fitr = FALSE)
}
\arguments{
\item{df}{Data frame with localization coordinates (X,Y).}

\item{unit}{Unit of the coordinates (default: 'cm')}

\item{vrbl}{Variable of coordinates (default: 'tap')}

\item{r}{Radius of the circle the coordinates should be on (default: 1).}

\item{fitr}{(boolean) Should radius be fit? (default: FALSE)}
}
\value{
The data frame with corrected \code{tapx_cm} and \code{tapy_cm} 
columns. The corrected localization responses fall closest to a circle with
radius \code{r} (in \code{unit}) and origin (0,0). Only response with
\code{df$selected == 1} are used for this correction.
}
\description{
Shift localization responses so they are centred on the origin
}
\details{
The parameters \code{vrbl} and \code{unit} are combined with a lower
case \code{x} and \code{y}: \code{tapx_cm} and \code{tapy_cm} with default
settings. These should be columns in the data frame (\code{df}).
}
\examples{

data("localization_aligned")
data("localization_unaligned")

localization_aligned <- convert2cm(localization_aligned, from='r')
localization_aligned <- convert2cm(localization_aligned, from='t')

par(mfrow=c(1,2))

plot(localization_aligned$tapx_cm, localization_aligned$tapy_cm, 
     main='aligned',xlab='cm', ylab='cm', 
     asp=1,bty='n', xlim=c(-2,12),ylim=c(-2,12),col='blue')
segments(localization_aligned$tapx_cm, localization_aligned$tapy_cm, 
         localization_aligned$handx_cm, localization_aligned$handy_cm, col='blue')
lines(c(-1,11),c(0,0),col='gray')
lines(c(0,0),c(-1,11),col='gray')
lines(cos(seq(0,pi/2,pi/200))*10,sin(seq(0,pi/2,pi/200))*10, col='gray')
centre <- circleFit(localization_aligned$tapx_cm, localization_aligned$tapy_cm, r=10)$par
points(centre['xc'], centre['yc'], col='red')
lines( (cos(seq(0,pi/2,pi/200))*10) + centre['xc'], (sin(seq(0,pi/2,pi/200))*10) + centre['yc'], col='red', lty=2)
points(localization_aligned$tapx_cm - centre['xc'], localization_aligned$tapy_cm - centre['yc'], col='green')
segments(localization_aligned$tapx_cm - centre['xc'], localization_aligned$tapy_cm - centre['yc'], 
         localization_aligned$handx_cm, localization_aligned$handy_cm, col='green')


localization_unaligned <- convert2cm(localization_unaligned, from='r')
localization_unaligned <- convert2cm(localization_unaligned, from='t')

plot(localization_unaligned$tapx_cm, localization_unaligned$tapy_cm, 
     main='unaligned',xlab='cm', ylab='cm', 
     asp=1,bty='n', xlim=c(-2,12),ylim=c(-2,12),col='blue')
segments(localization_unaligned$tapx_cm, localization_unaligned$tapy_cm, 
         localization_unaligned$handx_cm, localization_unaligned$handy_cm, col='blue')
lines(c(-1,11),c(0,0),col='gray')
lines(c(0,0),c(-1,11),col='gray')
lines(cos(seq(0,pi/2,pi/200))*10,sin(seq(0,pi/2,pi/200))*10, col='gray')
centre <- circleFit(localization_unaligned$tapx_cm, localization_unaligned$tapy_cm, r=10)$par
points(centre['xc'], centre['yc'], col='red')
lines( (cos(seq(0,pi/2,pi/200))*10) + centre['xc'], (sin(seq(0,pi/2,pi/200))*10) + centre['yc'], col='red', lty=2)
points(localization_unaligned$tapx_cm - centre['xc'], localization_unaligned$tapy_cm - centre['yc'], col='green')
segments(localization_unaligned$tapx_cm - centre['xc'], localization_unaligned$tapy_cm - centre['yc'], 
         localization_unaligned$handx_cm, localization_unaligned$handy_cm,, col='green')
}
